---
layout:     post
title:      "Leetcode164"
subtitle:   "最大间距"
date:       2020-3-16 10:00:00
author:     "TerryRen"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - algorithm
    - leetcode
---
题目要求：

给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。



示例 1：
```
输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
```


示例 2：
```
输入: [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
```
说明:

你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。
##双指针法

定睛一看，发现这题目岂不是很简单，排个序再遍历一圈找最大间隔就完事了。

然而这道是困难题，事情并不简单。。。果然，说明里有要求线性时间复杂度，也就是O(n),刚才说的方法得O(nlogn)了。

时间复杂度：O(n)。

空间复杂度：O(1)，只需要常数空间（不包括存储压缩答案的空间）。



### python的code如下：


```python
class Solution:
    def compressString(self, S: str) -> str:
        if not S:return S
        new_s=""+S[0]
        new,flag=0,1 #new是新字符串的指针，flag是出现次数
        lens=len(S)
        for i in range(1,lens): #i是原来字符串的指针
            if new_s[new]!=S[i]:
                new_s+=str(flag)
                new=new+len(str(flag))+1
                new_s+=S[i]
                flag=1               
            else:flag+=1
        new_s+=str(flag)
        return new_s if len(new_s)<lens else S
```
执行用时 :56 ms, 在所有 Python3 提交中击败了76.34%的用户

内存消耗 :13.5 MB, 在所有 Python3 提交中击败了100.00%的用户
### c++的code如下：

```c

```
