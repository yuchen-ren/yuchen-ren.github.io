---
layout:     post
title:      "Leetcode206"
subtitle:   " 反转链表"
date:       2020-3-2 15:00:00
author:     "TerryRen"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - algorithm
    - leetcode
---
题目要求：

反转一个单链表。

示例:
```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

## 题的解释
第一遍读没独懂（捂脸）。。。看了一些解释和英文题目才明白

来回切换中英文才把题目看懂，数组每位都是single digit，
所以只能是0-9的个位数，整个数没有leading zero，意思就是数组第一个数必非0，
再就是要注意，像[9,9]输出就是[1,0,0]。

## 使用遍历
此题分为三种情况：
* 普通情况，加1后无需进位的数，例如1234和3425等大部分数。
* 特殊情况，每一位不全为9，即加1后不是10的幂次，如69和549.
* 特殊情况，所有位都是9，加1后增加一位，例如9和9999.

于是从后往前遍历，先由最后一位判断是否需要进位，然后再看是否全为9.
### c++的code如下：


```c
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int lens=digits.size();
        for(int i=lens-1;i>=0;i--)
        {
            if(digits[i]!=9)
            {
                digits[i]+=1;
                return digits;
            }
            else digits[i]=0;             
        }
        digits.insert(digits.begin(),1);
        return digits;       
    }
};
```
执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗 :11.2 MB, 在所有 C++ 提交中击败了5.31%的用户
### python的code如下：


```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        lens=len(digits)
        for i in range(lens-1,-1,-1):
            if digits[i] != 9 :
                digits[i]+=1
                return digits
            else:
                digits[i]=0
        digits.insert(0,1)
        return digits
```
执行用时 :32 ms, 在所有 Python3 提交中击败了86.64%的用户

内存消耗 :13.3 MB, 在所有 Python3 提交中击败了26.68%的用户

